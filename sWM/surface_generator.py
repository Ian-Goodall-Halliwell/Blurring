#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Shifts a white matter surface inward along a Laplace field

Parameters
----------
GIFTI  :    str
            White matter surface in GIFTI format (surf.gii)
NIFTI  :    str
            laplacian image generated by laplace_solver.py
OUTPUT :    str
            path and name to the output surfaces
DEPTHS :    list [int | float] (OPTIONAL)
            DEFAULT=[1,2,3] List of depths to sample (in mm)

Returns
-------
NIFTI
    a list of strings representing the header columns

Usage
-----
surface_generator.py hemi-L_label-white.surf.gii laplace-wm.nii.gz hemi-L_label-sWF_depth-

Created on October 2023

@author: Jordan DeKraker
code from https://github.com/khanlab/hippunfold/blob/master/hippunfold/workflow/scripts/create_warps.py

"""

import copy
import nibabel as nib
import numpy as np
from scipy.interpolate import RegularGridInterpolator
import sys


def arg2float_list(arg):
    return list(map(float, arg.split(",")))


def shift_surface(in_surf, in_laplace, out_surf_prefix, depth_mm=[1, 2, 3]):
    print("starting surface shift")

    # load data
    surf = nib.load(in_surf)
    V = surf.get_arrays_from_intent("NIFTI_INTENT_POINTSET")[0].data
    F = surf.get_arrays_from_intent("NIFTI_INTENT_TRIANGLE")[0].data
    laplace = nib.load(in_laplace)
    lp = laplace.get_fdata()
    print("loaded data and parameters")

    # Get image resolution
    xres, yres, zres = laplace.affine[0, 0], laplace.affine[1, 1], laplace.affine[2, 2]

    # Convert depths from mm to voxels
    depth_vox = np.array(depth_mm) / xres

    # Convert depth values to strings with a specific format
    depth_str = [f"{d:.1f}" for d in depth_mm]  # Use one decimal place

    convergence_threshold = 1e-4
    step_size = 0.1  # vox
    max_iters = int(np.max(np.diff(depth_vox)) / step_size) * 10

    # laplace to gradient
    dx, dy, dz = np.gradient(lp)

    # Scale the gradients by the image resolutions to handle anisotropy
    dx /= xres
    dy /= yres
    dz /= zres

    distance_travelled = np.zeros(len(V))
    for d, d_str in zip(depth_vox, depth_str):
        # apply inverse affine to surface to get to matrix space
        V = (V - laplace.affine[:3, 3].T) / laplace.affine[:3, :3].diagonal()

        for i in range(max_iters):
            pts = distance_travelled < d
            V_tmp = V[pts].astype(int)
            stepx = dx[V_tmp[:, 0], V_tmp[:, 1], V_tmp[:, 2]]
            stepy = dy[V_tmp[:, 0], V_tmp[:, 1], V_tmp[:, 2]]
            stepz = dz[V_tmp[:, 0], V_tmp[:, 1], V_tmp[:, 2]]
            magnitude = np.sqrt(stepx**2 + stepy**2 + stepz**2)
            nonzero_magnitude = magnitude > 0
            stepx[nonzero_magnitude] *= step_size / magnitude[nonzero_magnitude]
            stepy[nonzero_magnitude] *= step_size / magnitude[nonzero_magnitude]
            stepz[nonzero_magnitude] *= step_size / magnitude[nonzero_magnitude]
            V[pts, 0] += stepx
            V[pts, 1] += stepy
            V[pts, 2] += stepz
            distance_travelled[pts] += step_size
            ssd = np.sum((V[pts] - V[pts]) ** 2)
            print(f"iteration {i}, convergence: {ssd}, still moving: {np.sum(pts)}")
            if ssd < convergence_threshold:
                break

        # return to world coords
        V = V * laplace.affine[:3, :3].diagonal() + laplace.affine[:3, 3].T

        nib.save(surf, out_surf_prefix + d_str + "mm.surf.gii")
        print(f"saved {out_surf_prefix}{d_str}mm.surf.gii")


if __name__ == "__main__":
    in_surf = sys.argv[1]
    in_laplace = sys.argv[2]
    out_surf_prefix = sys.argv[3]
    if len(sys.argv) > 4:
        depth_mm = arg2float_list(sys.argv[4])
    else:
        depth_mm = [1, 2, 3]  # default depths in mm

    shift_surface(in_surf, in_laplace, out_surf_prefix, depth_mm)
